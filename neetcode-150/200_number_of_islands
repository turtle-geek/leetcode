    class Solution {
    public:
        /**
         * Time Complexity: O(m*n) m is rows and n is columns
         * Space Complexity: O(min(m,n)) for bfs queue
         */
        int numIslands(vector<vector<char>>& grid) {
            if (grid.empty()) return 0;
            
            int rows = grid.size();
            int cols = grid[0].size();
            int islandCount = 0;

            for(int r = 0; r < rows; r++){
                for(int c = 0; c < cols; c++){
                    if(grid[r][c] == '1'){
                        islandCount++;
                        bfs(grid, r, c);
                    }
                }
            }
            return islandCount;
        }

    private:
        void bfs(vector<vector<char>>& grid, int r, int c) {
            int rows = grid.size();
            int cols = grid[0].size();
            queue<pair<int, int>> q;
            
            q.push({r, c});
            grid[r][c] = '0';

            int dr[] = {-1, 1, 0, 0};
            int dc[] = {0, 0, -1, 1};

            while (!q.empty()) {
                auto [currR, currC] = q.front();
                q.pop();

                for (int i = 0; i < 4; i++) {
                    int nr = currR + dr[i];
                    int nc = currC + dc[i];

                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == '1') {
                        grid[nr][nc] = '0';
                        q.push({nr, nc});
                    }
                }
            }
        }
    };